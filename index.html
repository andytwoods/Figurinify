<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Figurinify — Base & STL Exporter</title>
  <link rel="stylesheet" href="style.css" />
  <meta name="theme-color" content="#111" />
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <div class="section">
        <label for="dndSizeSelect">D&D size (real-life)</label>
        <select id="dndSizeSelect">
          <option>Small</option>
          <option selected>Medium</option>
          <option>Large</option>
        </select>
        <div class="note"><small id="dndSizeDesc"></small></div>
      </div>
      <div class="section">
        <label for="figurineSizeSelect">Figurine size to print</label>
        <select id="figurineSizeSelect">
          <option>Small</option>
          <option selected>Medium</option>
          <option>Large</option>
        </select>
        <div class="note">
          <span>Recommended height (cm): <strong id="recHeightCm">3.2–3.8</strong></span><br />
          <span>Recommended base diameter (cm): <strong id="recBaseCm">2.5</strong></span>
        </div>
      </div>
      
      <div class="section">
        <label for="baseRadius">Base diameter (cm)</label>
        <input id="baseRadius" type="range" min="1" max="16" step="0.5" value="2.5" />
        <span id="baseRadiusValue">2.5</span>
        <div class="note"><small id="baseRadiusDesc"></small></div>
      </div>
      <div class="section">
        <label for="baseHeight">Base height (mm)</label>
        <input id="baseHeight" type="number" min="1" max="20" step="0.5" value="1" />
      </div>
      <div class="section">
        <label for="fileInput">Load model (.glb recommended)</label>
        <input id="fileInput" type="file" accept=".glb,.gltf,.bin,.png,.jpg,.jpeg,.ktx2" multiple />
      </div>
      <div class="section row">
        <button id="resetView">Reset View</button>
        <button id="exportSTL" class="primary">Export STL</button>
      </div>
    </div>
    <div id="viewport"></div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
// Figurinify — load GLTF, add adjustable base, set target height, export STL
// Uses Three.js from CDN (ES modules). For best results, open via a local server.

import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { STLExporter } from 'https://unpkg.com/three@0.160.0/examples/jsm/exporters/STLExporter.js';

// DOM elements
const viewportEl = document.getElementById('viewport');
const baseRadiusSlider = document.getElementById('baseRadius');
const baseRadiusValue = document.getElementById('baseRadiusValue');
const baseRadiusDesc = document.getElementById('baseRadiusDesc');
const baseHeightInput = document.getElementById('baseHeight');
const fileInput = document.getElementById('fileInput');
const exportBtn = document.getElementById('exportSTL');
const resetViewBtn = document.getElementById('resetView');

// New UI elements for D&D size and figurine size presets
const dndSizeSelect = document.getElementById('dndSizeSelect');
const dndSizeDesc = document.getElementById('dndSizeDesc');
const figurineSizeSelect = document.getElementById('figurineSizeSelect');
const recHeightCmEl = document.getElementById('recHeightCm');
const recBaseCmEl = document.getElementById('recBaseCm');

// Data derived from provided JSON
const dndSizes = {
  Small: {
    description: 'Represents creatures such as halflings or gnomes.',
    height_range_cm: '90–120',
    example_creatures: ['Halfling', 'Gnome']
  },
  Medium: {
    description: 'Represents most humanoids such as humans, elves, orcs, etc.',
    height_range_cm: '120–240',
    example_creatures: ['Human', 'Elf', 'Orc']
  },
  Large: {
    description: 'Represents ogres, trolls, and similar large beings.',
    height_range_cm: '240–480',
    example_creatures: ['Ogre', 'Troll', 'Horse']
  }
};

const heroforgePrintSizes = {
  Small: {
    description: 'Scaled for small creatures like gnomes and halflings.',
    standard_miniature: {
      height_range_cm: '2.3–2.8',
      base_diameter_cm: 2.5,
      base_radius_mm: 12.5
    },
    statuette_2x_scale: {
      height_range_cm: '4.6–5.6',
      base_diameter_cm: 5.0,
      base_radius_mm: 25
    },
    stl_custom_scale: {
      scalable: true,
      recommended_range_cm: '2.0–10.0',
      notes: 'STL files can be scaled manually in slicing software for home printing.'
    }
  },
  Medium: {
    description: 'Standard humanoid HeroForge miniature scale (roughly 30–32 mm scale).',
    standard_miniature: {
      height_range_cm: '3.2–3.8',
      base_diameter_cm: 2.5,
      base_radius_mm: 12.5
    },
    statuette_2x_scale: {
      height_range_cm: '6.4–7.6',
      base_diameter_cm: 5.0,
      base_radius_mm: 25
    },
    stl_custom_scale: {
      scalable: true,
      recommended_range_cm: '3.0–15.0',
      notes: 'STL files can be printed at custom scales or for display models.'
    }
  },
  Large: {
    description: 'Used for ogres, trolls, mounts, and other large creatures.',
    standard_miniature: {
      height_range_cm: '5.5–7.0',
      base_diameter_cm: 5.0,
      base_radius_mm: 25
    },
    statuette_2x_scale: {
      height_range_cm: '11.0–14.0',
      base_diameter_cm: 10.0,
      base_radius_mm: 50
    },
    stl_custom_scale: {
      scalable: true,
      recommended_range_cm: '6.0–25.0',
      notes: "Physical HeroForge prints can be upscaled through their 'Refined XL' options or scaled manually if printed at home."
    }
  }
};

function parseRangeCm(rangeStr) {
  // Accepts strings like '3.2–3.8' or '3.2-3.8'
  const parts = rangeStr.replace(/\s/g, '').split(/[–-]/);
  if (parts.length !== 2) return null;
  const min = parseFloat(parts[0]);
  const max = parseFloat(parts[1]);
  if (!isFinite(min) || !isFinite(max)) return null;
  return [min, max];
}

function chooseFromRange([min, max], bias) {
  if (!isFinite(min) || !isFinite(max)) return null;
  // Exact mapping:
  // 'low' (D&D Small)   -> min of range
  // 'mid' (D&D Medium)  -> midpoint of range
  // 'high' (D&D Large)  -> max of range
  switch (bias) {
    case 'low': return min;
    case 'high': return max;
    default: return (min + max) / 2;
  }
}

function updateDndDesc(sizeKey) {
  const s = dndSizes[sizeKey];
  if (!s) { dndSizeDesc.textContent = ''; return; }
  dndSizeDesc.textContent = `${s.description} Height: ${s.height_range_cm} cm. Examples: ${s.example_creatures.join(', ')}`;
}

function formatRadiusLabel(r) {
  return (r % 1 === 0) ? String(r) : r.toFixed(1);
}

function setBaseRadiusUI(rMm) {
  // Clamp to slider range
  const minR = Number(baseRadiusSlider.min);
  const maxR = Number(baseRadiusSlider.max);
  const clamped = Math.min(Math.max(rMm, minR), maxR);
  baseRadiusSlider.value = String(clamped);
  baseRadiusValue.textContent = formatRadiusLabel(clamped);
  return clamped;
}

function updatePresetUI(figSizeKey) {
  const ps = heroforgePrintSizes[figSizeKey];
  if (!ps) return;
  const hRange = ps.standard_miniature.height_range_cm;
  const baseCm = ps.standard_miniature.base_diameter_cm;
  const baseRadiusMm = ps.standard_miniature.base_radius_mm || (baseCm * 10) / 2;
  recHeightCmEl.textContent = hRange;
  recBaseCmEl.textContent = String(baseCm);

  // Update base diameter description
  baseRadiusDesc.textContent = `Recommended for ${figSizeKey} figurine: ${baseCm} cm diameter`;

  // Set base diameter slider to recommended value (clamped) and rebuild base using radius in mm
  const clamped = setBaseRadiusUI(baseCm);
  const radiusMM = clamped * 5; // diameter(cm) -> radius(mm)
  createOrUpdateBase(radiusMM, Number(baseHeightInput.value));
}

    function applyPresetToModel(dndSizeKey, figSizeKey) {
      const ps = heroforgePrintSizes[figSizeKey];
      if (!ps) return;
      const range = parseRangeCm(ps.standard_miniature.height_range_cm) || [3.0, 4.0];
      let bias = 'mid';
      if (dndSizeKey === 'Small') bias = 'low';
      else if (dndSizeKey === 'Large') bias = 'high';
      const targetHeightCm = chooseFromRange(range, bias);
      const targetHeightMm = Math.round(targetHeightCm * 10);

      if (modelGroup.children.length > 0) {
        // Reset scale before applying new scale to avoid cumulative scaling
        modelGroup.scale.setScalar(1);
        scaleModelToHeight(targetHeightMm);
        alignModelOnBase();
        centerModelXZ();
        //fitCameraToObject(exportGroup);
      }
    }

// THREE.js essentials
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
viewportEl.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 5000);
camera.position.set(120, 100, 160);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.target.set(0, 40, 0);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
hemi.position.set(0, 1, 0);
scene.add(hemi);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(100, 200, 100);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(2048, 2048);
dirLight.shadow.camera.near = 10;
dirLight.shadow.camera.far = 1000;
dirLight.shadow.camera.left = -200;
dirLight.shadow.camera.right = 200;
dirLight.shadow.camera.top = 200;
dirLight.shadow.camera.bottom = -200;
scene.add(dirLight);

// Ground grid (for reference only, not exported)
const grid = new THREE.GridHelper(400, 40, 0x444444, 0x222222);
scene.add(grid);

// Groups: we'll export this combined group
const exportGroup = new THREE.Group();
scene.add(exportGroup);

const modelGroup = new THREE.Group();
modelGroup.name = 'ModelGroup';
exportGroup.add(modelGroup);

let baseMesh = null;

// Overlap amount: sink model slightly into the base to ensure stability in prints
const MODEL_BASE_OVERLAP_MM = 0.5;
// Export orientation: rotate scene to Z-up for STL (most slicers expect Z-up)
const EXPORT_Z_UP = true;

// Materials
const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.0, roughness: 1.0 });

// Loading Manager + GLTF Loader
const loadingManager = new THREE.LoadingManager();
const loader = new GLTFLoader(loadingManager);

function resizeRenderer() {
  const rect = viewportEl.getBoundingClientRect();
  const width = Math.max(200, rect.width);
  const height = Math.max(200, rect.height);
  renderer.setSize(width, height, false);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resizeRenderer);


    function createOrUpdateBase(radiusMM, heightMM) {
      if (radiusMM <= 0) radiusMM = 1;
      if (heightMM <= 0) heightMM = 1;

      const segments = 64;
      const geometry = new THREE.CylinderGeometry(radiusMM, radiusMM, heightMM, segments);

      if (!baseMesh) {
        baseMesh = new THREE.Mesh(geometry, baseMaterial);
        baseMesh.receiveShadow = true;
        baseMesh.castShadow = false;
        exportGroup.add(baseMesh);
      } else {
        baseMesh.geometry.dispose();
        baseMesh.geometry = geometry;
      }
      // Position base so TOP is at y = 0 (base spans [-height, 0])
      baseMesh.position.set(0, -heightMM / 2, 0);

      // Keep the base diameter (cm) input/label in sync with the actual base geometry
      if (!isNaN(radiusMM)) {
        const diameterCm = radiusMM * 0.2; // radius(mm) -> diameter(cm)
        setBaseRadiusUI(diameterCm);
      }
    }
function computeBBox(object3d) {
  const box = new THREE.Box3().setFromObject(object3d);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);
  return { box, size, center };
}

function alignModelOnBase() {
  // Move model so its lowest point sits slightly below the base top (negative Y),
  // to ensure a small overlap for stable printing.
  const { box } = computeBBox(modelGroup);
  if (!isFinite(box.min.y) || !isFinite(box.max.y)) return;
  const minY = box.min.y;
  // Target lowest point to be at -MODEL_BASE_OVERLAP_MM (base top is at y=0)
  modelGroup.position.y += -(minY + MODEL_BASE_OVERLAP_MM);
}

function centerModelXZ() {
  const { box, center } = computeBBox(modelGroup);
  if (!isFinite(center.x) || !isFinite(center.z)) return;
  const offsetX = -center.x;
  const offsetZ = -center.z;
  modelGroup.position.x += offsetX;
  modelGroup.position.z += offsetZ;
}

function scaleModelToHeight(targetHeightMM) {
  // Compute current height of modelGroup (before alignment), then scale uniformly
  const { box } = computeBBox(modelGroup);
  const currentHeight = box.max.y - box.min.y;
  if (currentHeight <= 0) return;
  const s = targetHeightMM / currentHeight;
  modelGroup.scale.setScalar(s);
}

function fitCameraToObject(object, padding = 20) {
  const { box, size, center } = computeBBox(object);
  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
  cameraZ *= 1.2; // a bit further

  camera.position.set(center.x + cameraZ, center.y + cameraZ * 0.6, center.z + cameraZ);
  controls.target.copy(new THREE.Vector3(center.x, Math.max(0, center.y - size.y / 2), center.z));
  controls.update();
}

async function loadDefaultModel() {
  try {
    const gltf = await loader.loadAsync('model/scene.gltf');
    setModelFromGLTF(gltf);
  } catch (e) {
    console.warn('Could not load default model from model/scene.gltf. If you opened this page via file://, browsers block fetching local files for security (CORS). Start a local server and open http://localhost/... or use the file picker to load a .glb.', e);
  }
}

function clearGroup(group) {
  for (let i = group.children.length - 1; i >= 0; i--) {
    const child = group.children[i];
    group.remove(child);
  }
}

function enableShadows(object, cast = true, receive = true) {
  object.traverse((obj) => {
    if (obj.isMesh) {
      obj.castShadow = cast;
      obj.receiveShadow = receive;
    }
  });
}

    function setModelFromGLTF(gltf) {
      clearGroup(modelGroup);

      const root = gltf.scene || gltf.scenes?.[0];
      modelGroup.add(root);
      enableShadows(root, true, true);

      // Apply presets for base and model
      const dnd = dndSizeSelect.value;
      const fig = figurineSizeSelect.value;
      updatePresetUI(fig);

      // Initial normalization: center XZ, bring feet to y=0, scale to preset height, then realign
      centerModelXZ();
      alignModelOnBase();
      const ps = heroforgePrintSizes[fig];
      if (ps) {
        const range = parseRangeCm(ps.standard_miniature.height_range_cm) || [3.0, 4.0];
        let bias = 'mid';
        if (dnd === 'Small') bias = 'low';
        else if (dnd === 'Large') bias = 'high';
        const targetHeightCm = chooseFromRange(range, bias);
        const targetHeightMm = Math.round(targetHeightCm * 10);
        scaleModelToHeight(targetHeightMm);
      }
      centerModelXZ();
      alignModelOnBase();

      fitCameraToObject(exportGroup);
    }

// Build a resolver that maps dependency URLs in a .gltf to user-selected Files
function makeFileResolver(files) {
  const fileMap = new Map();
  for (const f of files) {
    fileMap.set(f.name.toLowerCase().replace(/^\.\//, ''), f);
  }
  loadingManager.setURLModifier((url) => {
    const clean = url.split('?')[0].split('#')[0].toLowerCase().replace(/^\.\//, '');
    let candidate = fileMap.get(clean);
    if (candidate) return URL.createObjectURL(candidate);
    const last = clean.substring(clean.lastIndexOf('/') + 1);
    candidate = fileMap.get(last);
    if (candidate) return URL.createObjectURL(candidate);
    return url;
  });
  return () => {
    loadingManager.setURLModifier(null);
  };
}

function handleFiles(fileList) {
  const files = Array.from(fileList);
  // Prefer GLB when present
  const glb = files.find(f => f.name.toLowerCase().endsWith('.glb'));
  if (glb) {
    const url = URL.createObjectURL(glb);
    loader.load(url, (gltf) => {
      setModelFromGLTF(gltf);
      URL.revokeObjectURL(url);
    }, undefined, (err) => {
      console.error('Failed to load GLB:', err);
      URL.revokeObjectURL(url);
    });
    return;
  }

  // Otherwise, try GLTF + its dependencies from the same selection
  const gltfFile = files.find(f => f.name.toLowerCase().endsWith('.gltf'));
  if (gltfFile) {
    const cleanup = makeFileResolver(files);
    const url = URL.createObjectURL(gltfFile);
    loader.load(url, (gltf) => {
      setModelFromGLTF(gltf);
      URL.revokeObjectURL(url);
      cleanup();
    }, undefined, (err) => {
      console.error('Failed to load GLTF:', err);
      URL.revokeObjectURL(url);
      cleanup();
    });
    return;
  }

  alert('Please select a .glb, or a .gltf together with its .bin and textures.');
}

function doExportSTL() {
  // Export the exportGroup (model + base), robustly handling STLExporter outputs
  const exporter = new STLExporter();

  // Ensure we have something exportable
  let hasMesh = false;
  exportGroup.traverse((o) => {
    if (o.isMesh && o.geometry) hasMesh = true;
  });
  if (!hasMesh) {
    alert('Nothing to export: no meshes found.');
    return;
  }

  // Prepare a target group for export. Rotate to Z-up if requested, without affecting the scene.
  let target = exportGroup;
  if (EXPORT_Z_UP) {
    // Deep clone transforms/graph; geometries/materials are shared (fine for export)
    target = exportGroup.clone(true);
    // Reset clone world matrices to match current scene
    exportGroup.updateMatrixWorld(true);
    target.updateMatrixWorld(true);
    // Apply Y-up (Three.js) -> Z-up (slicers) conversion: rotate +90° around X (Y -> Z)
    target.rotation.x = (target.rotation.x || 0) + Math.PI / 2;
    target.updateMatrixWorld(true);
  } else {
    // Make sure matrices are up to date if no clone is used
    exportGroup.updateMatrixWorld(true);
  }

  const toBlob = (res, isBinary) => {
    if (!res) return null;
    const binType = 'application/vnd.ms-pki.stl';
    if (res instanceof ArrayBuffer) return new Blob([res], { type: binType });
    if (ArrayBuffer.isView(res)) return new Blob([res.buffer], { type: binType });
    if (typeof res === 'string') return new Blob([res], { type: 'text/plain' });
    return null;
  };

  let blob = null;
  let filename = 'figure_with_base.stl';

  // Try binary first
  let result;
  try {
    result = exporter.parse(target, { binary: true });
    blob = toBlob(result, true);
  } catch (e) {
    console.warn('Binary STL export threw an error, will try ASCII next:', e);
  }

  // Fallback to ASCII if needed
  if (!blob) {
    try {
      const ascii = exporter.parse(target, { binary: false });
      blob = toBlob(ascii, false);
      filename = 'figure_with_base_ascii.stl';
      if (!blob) {
        console.error('Unexpected STL export result type in ASCII mode:', ascii && ascii.constructor && ascii.constructor.name);
        alert('Export failed: Unexpected result from STL exporter (ASCII). See console for details.');
        return;
      }
    } catch (e) {
      console.error('ASCII STL export failed:', e);
      alert('Export failed: STL exporter error. See console for details.');
      return;
    }
  }

  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  URL.revokeObjectURL(link.href);
}

// UI handlers
// D&D and figurine size selectors
function syncFromSelectors() {
  const dnd = dndSizeSelect.value;
  const fig = figurineSizeSelect.value;
  updateDndDesc(dnd);
  updatePresetUI(fig);
  applyPresetToModel(dnd, fig);
}

dndSizeSelect.addEventListener('change', () => {
      // Nudge height within the current figurine size based on D&D size
      const dnd = dndSizeSelect.value;
      const fig = figurineSizeSelect.value;
      updateDndDesc(dnd);
      // Also reset base radius to the recommended value for the current figurine size
      updatePresetUI(fig);
      applyPresetToModel(dnd, fig);
    });

figurineSizeSelect.addEventListener('change', () => {
  syncFromSelectors();
});
baseRadiusSlider.addEventListener('input', () => {
  const diameterCm = Number(baseRadiusSlider.value);
  baseRadiusValue.textContent = formatRadiusLabel(diameterCm);
  const radiusMM = diameterCm * 5; // diameter(cm) -> radius(mm)
  createOrUpdateBase(radiusMM, Number(baseHeightInput.value));
  // Optionally keep camera focus at center
});

baseHeightInput.addEventListener('change', () => {
  const diameterCm = Number(baseRadiusSlider.value);
  const radiusMM = diameterCm * 5; // diameter(cm) -> radius(mm)
  createOrUpdateBase(radiusMM, Number(baseHeightInput.value));
});

fileInput.addEventListener('change', (e) => {
  const fl = e.target.files;
  if (fl && fl.length > 0) handleFiles(fl);
});

resetViewBtn.addEventListener('click', () => {
  fitCameraToObject(exportGroup);
});

exportBtn.addEventListener('click', () => {
  doExportSTL();
});

// Drag and drop (optional convenience)
window.addEventListener('dragover', (e) => {
  e.preventDefault();
});
window.addEventListener('drop', (e) => {
  e.preventDefault();
  const fl = e.dataTransfer?.files;
  if (fl && fl.length > 0) handleFiles(fl);
});

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// Initial setup
function init() {
  resizeRenderer();

  // Sync UI with defaults
  figurineSizeSelect.value = figurineSizeSelect.value || 'Medium';
  dndSizeSelect.value = dndSizeSelect.value || 'Medium';
  updateDndDesc(dndSizeSelect.value);
  updatePresetUI(figurineSizeSelect.value);
  applyPresetToModel(dndSizeSelect.value, figurineSizeSelect.value);

  // Create base with current diameter(cm) converted to radius(mm)
  const initDiameterCm = Number(baseRadiusSlider.value);
  const initRadiusMM = initDiameterCm * 5; // diameter(cm) -> radius(mm)
  createOrUpdateBase(initRadiusMM, Number(baseHeightInput.value));

  // Load default showcase model
  loadDefaultModel();
  animate();
}

init();
  </script>
</body>
</html>
